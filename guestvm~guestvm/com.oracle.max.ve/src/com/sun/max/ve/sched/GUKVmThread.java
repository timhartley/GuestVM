/*
 * Copyright (c) 2009, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.max.ve.sched;

import com.sun.max.ve.guk.*;
import com.sun.max.vm.thread.*;
import com.sun.max.annotate.*;
import com.sun.max.unsafe.*;
import static com.sun.cri.bytecode.Bytecodes.*;
import com.sun.cri.bytecode.*;

/**
 * A subclass of VmThread that is tied to the Guest VM microkernel (GUK) native thread.
 *
 * @author Harald Roeck
 * @author Mick Jordan
 *
 */

public class GUKVmThread extends VmThread {

    private int _cpu; // cpu the thread is running or scheduled to run on
    private boolean _running; // true if this thread is running or scheduled to run next
    private boolean _notified; //  true if condition notification received
    private GUKVmThread _nextWaiting; /* for waiting list in mutex and condition variables */


    /*
     * The following values have to match the ukernel flag definitions in guk/include/guk/sched.h.
     */
    public static final int RUNNABLE_FLAG = 0x00000001;
    public static final int RUNNING_FLAG = 0x00000002;
    public static final int RESCHED_FLAG = 0x00000004;
    public static final int DYING_FLAG = 0x00000008;
    public static final int INTERRUPTED_FLAG = 0x00000080;
    public static final int UKERNEL_FLAG = 0x00000100;
    public static final int JOIN_FLAG = 0x00000200;
    public static final int AUX1_FLAG = 0x00000400;
    public static final int AUX2_FLAG = 0x00000800;
    public static final int SLEEP_FLAG = 0x00001000;
    public static final int APPSCHED_FLAG = 0x00002000;
    public static final int WATCH_FLAG = 0x00004000;

    /**
     * Size of the guk thread control block.
     */
    public static final int STRUCT_THREAD_SIZE = 200;
    /**
     * Byte (address) offsets into the native thread struct. Generated by guk/tools/printoffsets/print_thread_offsets.
     */
    public static final int PREEMPT_COUNT_OFFSET = 0;
    public static final int FLAGS_OFFSET = 4;
    public static final int REGS_OFFSET = 8;
    public static final int FPREGS_OFFSET = 16;
    public static final int ID_OFFSET = 24;
    public static final int APPSCHED_ID_OFFSET = 26;
    public static final int GUK_STACK_ALLOCATED_OFFSET = 28;
    public static final int NAME_OFFSET = 32;
    public static final int STACK_OFFSET = 40;
    public static final int STACK_SIZE_OFFSET = 48;
    public static final int SPECIFIC_OFFSET = 56;
    public static final int TIMESLICE_OFFSET = 64;
    public static final int RESCHED_RUNNING_TIME_OFFSET = 72;
    public static final int START_RUNNING_TIME_OFFSET = 80;
    public static final int CUM_RUNNING_TIME_OFFSET = 88;
    public static final int CPU_OFFSET = 96;
    public static final int LOCK_COUNT_OFFSET = 100;
    public static final int SP_OFFSET = 104;
    public static final int IP_OFFSET = 112;
    public static final int THREAD_LIST_OFFSET = 120;
    public static final int READY_LIST_OFFSET = 136;
    public static final int JOINERS_OFFSET = 152;
    public static final int AUX_THREAD_LIST_OFFSET = 168;
    public static final int DB_DATA_OFFSET = 184;
    public static final int R14_SAVE_OFFSET = 192;

    // Maxine's typed methods scale the offset according to type
    public static final int START_RUNNING_TIME_OFFSET_AS_LONG = START_RUNNING_TIME_OFFSET / 8;
    public static final int CUM_RUNNING_TIME_OFFSET_AS_LONG = CUM_RUNNING_TIME_OFFSET / 8;
    public static final int FLAGS_OFFSET_ASINT = FLAGS_OFFSET / 4;
    public static final int CPU_OFFSET_ASINT = CPU_OFFSET / 4;
    public static final int ID_OFFSET_AS_SHORT = ID_OFFSET / 2;
    public static final int STACK_OFFSET_AS_LONG = STACK_OFFSET / 8;
    public static final int STACK_SIZE_OFFSET_AS_LONG = STACK_SIZE_OFFSET / 8;

    /**
     * Size of guk list head struct.
     */
    public static final int STRUCT_LIST_HEAD_SIZE = 16;
    /**
     * Offsets into guk list head struct.
     */
    public static final int NEXT_OFFSET = 0;
    public static final int PREV_OFFSET = 8;

    public GUKVmThread() {
        super();
        _running = false;
        _cpu = -1;
        _nextWaiting = null;
        _notified = false;
    }

    // all VmThreads are GUKVmThreads
    @INTRINSIC(UNSAFE_CAST) private static GUKVmThread asGUKVmThread(Object object) { return (GUKVmThread) object; }

    @INLINE
    public static GUKVmThread current() {
        return asGUKVmThread(VmThread.current());
    }

    @Override
    protected void initializationComplete() {
        GUKScheduler.attachThread(nativeThread, id());
    }

    @Override
    protected void terminationPending() {
        GUKScheduler.detachThread(nativeThread);
    }

    @INLINE
    public final int nativeId() {
        return nativeThread.asPointer().getShort(ID_OFFSET_AS_SHORT);
    }

    public final int safeNativeId() {
        if (nativeThread.isZero()) {
            return -1;
        }
        return nativeId();
    }

    /**
     * Gets the cumulative CPU running time for this thread.
     * @return
     */
    public final long getRunningTime() {
        // The CUM_RUNNING_TIME field is only updated on a thread re-schedule so we have to repeat that code here
        // as we do not want to enter the scheduler!
        final Pointer ntp = nativeThread.asPointer();
        // this is the cumulative running time for this cpu when this thread was last scheduled onto the cpu
        final long start_running_time = ntp.getLong(START_RUNNING_TIME_OFFSET_AS_LONG);
        // this is the cumulative running time for this cp now
        final long this_running_time = GUKScheduler.getCPURunningTime(ntp.getInt(CPU_OFFSET_ASINT));
        // this is the cumulative running time for this thread at the last schedule
        final long prev_cum_running_time = ntp.getLong(CUM_RUNNING_TIME_OFFSET_AS_LONG);
        return prev_cum_running_time + (this_running_time - start_running_time);
    }

    public int compareTo(GUKVmThread sthread) {
        return this.javaThread().getPriority() - sthread.javaThread().getPriority();
    }

    @INLINE
    private void setFlags(int flags) {
        nativeThread.asPointer().setInt(FLAGS_OFFSET_ASINT, flags);
    }

    @INLINE
    private int getFlags() {
        return nativeThread.asPointer().getInt(FLAGS_OFFSET_ASINT);
    }

    @INLINE
    private void clearFlag(int flag) {
        int flags = getFlags();
        flags &= ~flag;
        setFlags(flags);
    }

    @INLINE
    private void setFlag(int flag) {
        int flags = getFlags();
        flags |= flag;
        setFlags(flags);
    }

    @INLINE
    private boolean isFlag(int flag) {
        return (getFlags() & flag) != 0;
    }

    @INLINE
    public final boolean isRunnable() {
        return isFlag(RUNNABLE_FLAG);
    }

    @INLINE
    public final void setRunnable(boolean runnable) {
        if (runnable) {
            setFlag(RUNNABLE_FLAG);
        } else {
            clearFlag(RUNNABLE_FLAG);
        }
    }

    @INLINE
    public final boolean isRunning() {
        /*
         * a thread is considered running if it is currently active as indicated by the flags or the scheduler decided
         * to run it next
         */
        return _running || isFlag(RUNNING_FLAG);
    }

    @INLINE
    public final void setRunning(boolean running) {
        _running = running;
    }

    @INLINE
    public final boolean isDying() {
        return isFlag(DYING_FLAG);
    }

    @INLINE
    public final boolean isSleeping() {
        return isFlag(SLEEP_FLAG);
    }

    @INLINE
    public final boolean isOSInterrupted() {
        return isFlag(INTERRUPTED_FLAG);
    }

    @INLINE
    public final void clearOSInterrupted() {
        clearFlag(INTERRUPTED_FLAG);
    }

    @INLINE
    public final void setNeedReSched() {
        setFlag(RESCHED_FLAG);
    }

    @INLINE
    public final void setConditionWait(boolean bool) {
        if (bool) {
            setFlag(AUX2_FLAG);
        } else {
            clearFlag(AUX2_FLAG);
        }
    }

    @INLINE
    public final void setMutexWait(boolean bool) {
        if (bool) {
            setFlag(AUX1_FLAG);
        } else {
            clearFlag(AUX1_FLAG);
        }
    }

    @INLINE
    public final boolean isJava() {
        return isFlag(APPSCHED_FLAG);
    }

    /**
     * Mark the thread as blocked or ready to run.
     */
    public void setSchedulable(boolean ready) {
        final Scheduler sched = SchedulerFactory.scheduler();
        if (ready) {
            if (sched.active()) {
                setRunnable(true);
                sched.wake(this);
            } else {
                wakeup();
            }
        } else {
            if (sched.active()) {
                setRunnable(false);
                sched.block(this);
            } else {
                block();
            }
        }
    }

    /** Set the cpu for the thread.
    * @param cpu the cpu to set
     */
    public void setCpu(int cpu) {
        this._cpu = cpu;
        nativeThread.asPointer().setInt(CPU_OFFSET_ASINT, cpu);
    }

    /**
     * @return the cpu
     */
    public int getCpu() {
        return _cpu;
    }

    /**
     * @return the _notified
     */
    public boolean isNotified() {
        return _notified;
    }

    /**
     * @param notified
     *                the _notified to set
     */
    public void setNotified(boolean notified) {
        this._notified = notified;
    }

    /**
     * @return the _nextWaiting
     */
    public GUKVmThread getNextWaiting() {
        return _nextWaiting;
    }

    /**
     * @param waiting
     *                the _nextWaiting to set
     */
    public void setNextWaiting(GUKVmThread waiting) {
        _nextWaiting = waiting;
    }

    @INLINE
    private void block() {
        GUKScheduler.block(nativeThread);
    }

    @INLINE
    private void wakeup() {
        GUKScheduler.wake(nativeThread);
    }

    @INLINE
    private static Pointer nativeThreadPointer() {
        return VmThread.current().nativeThread().asPointer();
    }

    /**
     * Disable pre-emption for the current thread.
     */
    @INLINE
    public static final void disablePreemption() {
        final Pointer ntp = nativeThreadPointer();
        ntp.setInt(1 + ntp.getInt(PREEMPT_COUNT_OFFSET));
    }

    @INLINE
    public static void enablePreemption() {
        final Pointer ntp = nativeThreadPointer();
        ntp.setInt(ntp.getInt() - 1);
        if ((ntp.getInt(FLAGS_OFFSET_ASINT) & RESCHED_FLAG) != 0) {
            GUKScheduler.preemptSchedule();
        }
    }

    @INLINE
    public static GUKVmThread getFromNative(Word nativeThread) {
        final int id = get_java_id(nativeThread);
        final GUKVmThread retval = (GUKVmThread) VmThreadMap.ACTIVE.getVmThreadForID(id);
        return retval;
    }

    @C_FUNCTION
    private static native int get_java_id(Word nativeThread);


}
